<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rpc on UnderTheHood</title>
    <link>https://wymli.github.io/categories/rpc/</link>
    <description>Recent content in rpc on UnderTheHood</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>CC BY 4.0 CN</copyright>
    <lastBuildDate>Sat, 27 Mar 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://wymli.github.io/categories/rpc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[DB] sql spec</title>
      <link>https://wymli.github.io/2021/03/db-sql-spec/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/db-sql-spec/</guid>
      <description>About sql statement&amp;amp;index spec 参考但不限于Java开发手册（嵩山版） 关于索引 与索引有关的注意事项,基本都集中在一个sql语句它到底是否正确使用了索引,这可以通过e</description>
    </item>
    
    <item>
      <title>[deploy] server deploy</title>
      <link>https://wymli.github.io/2021/03/deploy-server-deploy/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/deploy-server-deploy/</guid>
      <description>记一次云端部署web服务器 本来以为和在自己电脑上本地部署一样,没想到还是遇到很多自己不熟悉的地方,云端服务器会涉及到更多linux相关的知识</description>
    </item>
    
    <item>
      <title>[Go] concurrentMap</title>
      <link>https://wymli.github.io/2021/03/go-concurrentmap/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-concurrentmap/</guid>
      <description>Built-in map&amp;amp; sync.Map &amp;amp; ConcurrentMap 并发map,是指多线程安全的map数据结构, 我们知道go语言原生的map是不支持并发的, 要想获得一个并发map, 我们有如下的几种方</description>
    </item>
    
    <item>
      <title>[Go] errorx</title>
      <link>https://wymli.github.io/2021/03/go-errorx/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-errorx/</guid>
      <description>Error go的error一直是被人诟病的,对于菜鸡来说无非是每调用一个函数就要判断一下if err!=nil{return err} 而对于进阶一点的程序员,则会诟病它的error接口设</description>
    </item>
    
    <item>
      <title>[Go] escape analysis</title>
      <link>https://wymli.github.io/2021/03/go-escape-analysis/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-escape-analysis/</guid>
      <description>逃逸分析 首先,逃逸分析发生在编译时,由分析结果决定运行时对象应该在堆还是栈上分配 注意: 这个编译时分析似乎是以函数为单位的静态分析,因此才有当</description>
    </item>
    
    <item>
      <title>[Go] GC</title>
      <link>https://wymli.github.io/2021/03/go-gc/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-gc/</guid>
      <description>垃圾回收算法 https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/ 有两种常见的自动管理堆内存的方法: 引用计数/智能指针 追踪式垃圾回收(对堆内存的对象关系图进行可达性分析) 术语 根对象: 包括所有栈</description>
    </item>
    
    <item>
      <title>[Go] goroutine pool</title>
      <link>https://wymli.github.io/2021/03/go-goroutine-pool/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-goroutine-pool/</guid>
      <description>Goroutine Pool 代码来自:gobwas/ws-example 在go中,由于goroutine是完全的用户态线程,所以创建新线程的开销很小,在这种情况下,</description>
    </item>
    
    <item>
      <title>[Go] monkey patch</title>
      <link>https://wymli.github.io/2021/03/go-monkey-patch/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-monkey-patch/</guid>
      <description>Monkey patch 猴子补丁 ref: https://bou.ke/blog/monkey-patching-in-go/ Intro: 什么是monkey patch? package main func a() int { return 1 } func b() int { return 2 } func main() { replace(a, b) print(a()) // 2 } monkey patch将做到如上的效果,当你调用a函数时,实际</description>
    </item>
    
    <item>
      <title>[Go] mutex</title>
      <link>https://wymli.github.io/2021/03/go-mutex/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-mutex/</guid>
      <description>mutex 结构 type Mutex struct { state int32 sema uint32 } 自旋 for{ cas(m.state) } 阻塞 wait(m.sema) 状态 普通模式 就是正常的模式,线程相互竞争获得锁 饥饿模式 由于线程竞争失败会阻塞,而这些被唤醒的线程会和</description>
    </item>
    
    <item>
      <title>[Go] netaddr</title>
      <link>https://wymli.github.io/2021/03/go-netaddr/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-netaddr/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[Go] radix-tree</title>
      <link>https://wymli.github.io/2021/03/go-radix-tree/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-radix-tree/</guid>
      <description>Radix树 又叫压缩前缀树,基数树,常用于路由匹配上,会将路由组织成一颗radix树</description>
    </item>
    
    <item>
      <title>[Go] reflect</title>
      <link>https://wymli.github.io/2021/03/go-reflect/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-reflect/</guid>
      <description>什么是反射? 反射提供了一种运行时能对对象增删查改的方法. 换句话说,当函数参数的interface{}时,提供了一种访问原来的类型和值的方法.</description>
    </item>
    
    <item>
      <title>[Go] runtime struct builder</title>
      <link>https://wymli.github.io/2021/03/go-runtime-struct-builder/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-runtime-struct-builder/</guid>
      <description>Runtime Struct: 运行时结构体构造方法 参考: https://github.com/itsubaki/gostruct https://pkg.go.dev/reflect#example-StructOf reflect.New(typ reflect.Type) reflect.Value New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value&amp;rsquo;s Type is PtrTo(typ). 因此,给定一个结构体类型的type,我们就可以构造出</description>
    </item>
    
    <item>
      <title>[Go] short var declare</title>
      <link>https://wymli.github.io/2021/03/go-short-var-declare/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-short-var-declare/</guid>
      <description>[Go] 短变量声明 := 在Go中,提供了动态语言常用的一种直接声明并赋值的语法糖,即 := 短变量声明 := 这个符号,可能是借鉴了Pascal 短变量声明有一定的</description>
    </item>
    
    <item>
      <title>[Go] slice index detail</title>
      <link>https://wymli.github.io/2021/03/go-slice-index-detail/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-slice-index-detail/</guid>
      <description>[Go] Slice的下标索引细节 在刷oj的时候,经常遇到要对一个数组取一部分的场景,用来递归分治 常见的比如快排,恢复二叉树等 在c/c++中,我会使</description>
    </item>
    
    <item>
      <title>[Go] standard package layout</title>
      <link>https://wymli.github.io/2021/03/go-standard-package-layout/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-standard-package-layout/</guid>
      <description>Standard Package Layout 标准包布局 -Ben Johnson https://www.gobeyond.dev/standard-package-layout/ Vendoring和Generics,它们在go社区似乎都是big issue,但还有一个很少提及的issue,就是应用</description>
    </item>
    
    <item>
      <title>[Go] user thread</title>
      <link>https://wymli.github.io/2021/03/go-user-thread/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/go-user-thread/</guid>
      <description>用户线程与核心线程 ref: Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism 论文观点: We argue that the performance of user-levelthreads is inherently better than that of kernel threads, rather than thisbeing an artifact of existing implementations. kernel threads are the wrong abstraction on which to support user-level management of parallelism. 1.用户线程的</description>
    </item>
    
    <item>
      <title>[HTTP] Content-Type</title>
      <link>https://wymli.github.io/2021/03/http-content-type/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/http-content-type/</guid>
      <description>About Content-Type Content-Type 用来指定在POST请求中body的数据类型(或格式),是一个非常重要的Header字段 三种Content-Type application/x-www-form-urlencoded 默认类型,当for</description>
    </item>
    
    <item>
      <title>[interview] ByteDance&amp;Tencent</title>
      <link>https://wymli.github.io/2021/03/interview-bytedancetencent/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/interview-bytedancetencent/</guid>
      <description>ByteDance&amp;amp;Tencent 2021/3 暑期实习 腾讯一面 上来抛了道js,问我输出 const a = ( i : 0, toString(){ return i++ } ) print(a == 0 &amp;amp;&amp;amp; a==1 &amp;amp;&amp;amp; a==2) 答案是false,没答出来,我当时主要纠结于为什么会调用t</description>
    </item>
    
    <item>
      <title>[interview] 杂</title>
      <link>https://wymli.github.io/2021/03/interview-%E6%9D%82/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wymli.github.io/2021/03/interview-%E6%9D%82/</guid>
      <description>记录一下为面试做的准备 声明: 以下知识点可能不完全正确,但也不会错的太离谱 记录一些知识点 数据库事务的四个特性: ACID 原子性,一致性,隔离性,持久性</description>
    </item>
    
  </channel>
</rss>
